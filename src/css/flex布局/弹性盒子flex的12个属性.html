<!DOCTYPE html>
<!--容器属性-->
<!--flex-flow flex-direction justify-content flex-wrap align-items align-content-->
<!--元素属性-->
<!--flex flex-shrink flex-grow flex-basis order align-self-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>flex的12个属性</title>
</head>
<body>
    <!--flex-flow = flex-drection + flex-wrap-->
    <!--  flex-flow: row nowrap;  -->
    <!--主轴交叉轴等比较简单的就不总结了，主要总结元素属性-->
    <!--  当flex-wrap: nowrap;不折行时，容器宽度有剩余/不够分，弹性元素们该怎么“弹性”地伸缩应对？
        这里针对上面两种场景，引入两个属性(需应用在弹性元素上)
        flex-shrink：缩小比例（容器宽度<元素总宽度时如何收缩）
        flex-grow：放大比例（容器宽度>元素总宽度时如何伸展）  -->
    <!--  1. flex-shrink: 缩小比例
    来看下以下场景，弹性容器#container宽度是200px，一共有三个弹性元素，宽度分别是50px、100px、120px。在不折行的情况下，此时容器宽度是明显不够分配的。
    实际上，flex-shrink默认为1，也就是当不够分配时，元素都将等比例缩小，占满整个宽度。  -->
    <!--  元素收缩的计算方法
    真的是等比缩小(每个元素各减去70/3的宽度)吗？这里稍微深究一下它的收缩计算方法。
    弹性元素1：50px→37.03px
    弹性元素2：100px→74.08px
    弹性元素3：120px→88.89px
    先抛结论：flex-shrink: 1并非严格等比缩小，它还会考虑弹性元素本身的大小。
    容器剩余宽度：-70px
    缩小因子的分母：1*50 + 1*100 + 1*120 = 270 (1为各元素flex-shrink的值)
    元素1的缩小因子：1*50/270
    元素1的缩小宽度为缩小因子乘于容器剩余宽度：1*50/270 * (-70)
    元素1最后则缩小为：50px + (1*50/270 *(-70)) = 37.03px
    加入弹性元素本身大小作为计算方法的考虑因素，主要是为了避免将一些本身宽度较小的元素在收缩之后宽度变为0的情况出现。
      -->
    <!--  2. flex-grow: 放大比例
    同样，弹性容器#container宽度是200px，但此时只有两个弹性元素，宽度分别是50px、100px。此时容器宽度是有剩余的。
    那么剩余的宽度该怎样分配？而flex-grow则决定了要不要分配以及各个分配多少。
    （1）在flex布局中，容器剩余宽度默认是不进行分配的，也就是所有弹性元素的flex-grow都为0。  -->
    <!-- （2）通过指定flex-grow为大于零的值，实现容器剩余宽度的分配比例设置。-->
    <!--  元素放大的计算方法
    放大的计算方法并没有与缩小一样，将元素大小纳入考虑。
    仅仅按flex-grow声明的份数算出每个需分配多少，叠加到原来的尺寸上。
    容器剩余宽度：50px
    分成每份：50px / (3+2) = 10px
    元素1放大为：50px + 3 * 10 = 80px
    无多余宽度时，flex-grow无效  -->
    <div></div>
    <div></div>
    <div></div>
    <div></div>
</body>
</html>
