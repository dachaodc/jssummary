<!-- 看看输出什么值-->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
        }

    </style>
</head>
<body>
<div style="text-align: center">
    <!--    <button onclick="onClickButton()">点击</button>-->
</div>
</body>
<script>

    // function onClickButton() {
    // abhdcba
    // console.log('abcdcba'.replace(/c/, "h"));
    // console.log("点击");
    // for (let i = 0; i < 3; i++) {
    //     console.log(i);
    // }
    // }

    window.onload = function () {
        // // 0 1 2
        // for (let i = 0; i < 3; i++) {
        //     document.body.addEventListener('click', function () {
        //         console.log(i);
        //     });
        // }
        //
        // // 3 3 3
        // for (var i = 0; i < 3; i++) {
        //     document.body.addEventListener('click', function () {
        //         console.log(i);
        //     });
        // }


        // 1,2,3,4,5
        // const tempArr = [1,2,3,4,5];
        // for (let i = 0; i < tempArr.length; i++) {
        //     setTimeout( () => {
        //         console.log(tempArr[i]);
        //     },0)
        // }
        //
        // // 5 undefined 5 undefined 5 undefined 5 undefined 5 undefined
        // const tempArr2 = [1,2,3,4,5];
        // for (var i = 0; i < tempArr2.length; i++) {
        //     setTimeout( () => {
        //         console.log(i);
        //         console.log(tempArr2[i]);
        //     },0)
        // }


        // undefined
        // js链式作用域 JS权威指南的描述：
        // JavaScript中的函数运行在他们被定义的作用域里，而不是他们被执行的作用域里。
        // 这句话很难理解，但是换做简单的描述，JS的链式作用域就是：
        // JS中当遇到对变量名或者函数名的使用时，会首先在当前作用域查找变量或者函数,如果没有找到，就会到其上层作用域中寻找，并以此类推。
        // var a = 1;
        // function fn() {
        //     console.log(a);
        //     var a = 2;
        // }
        // fn();

        // Uncaught ReferenceError: Cannot access 'b' before initialization
        // let b = 1;
        // function fnb() {
        //     // console.log(b);
        //     // let b = 2;
        //     var bc = 3;
        //     var bc = 4;
        // }
        // fnb();

        // 20
        // var count = 10;
        // function a() {
        //     return count + 10;
        // }
        //
        // function b() {
        //     var count = 20;
        //     console.log(this);
        //     console.log(this.count);
        //     return a();
        // }
        //
        // let objj = {
        //     count: 50,
        //     dcdc: function dcdc() {
        //     return  this.count;
        // },
        // };
        //
        // var dcdcdc = objj.dcdc;
        // console.log(dcdcdc());
        // console.log(objj.dcdc());
        // console.log(b());
        //
        // // 错 2
        // Function.prototype.a = () => alert(1);
        // Object.prototype.b = () => alert(2);
        // function A() {};
        // var a = new A();
        // a.a();
        // console.log(a);
        // a.b();


        // 4 5 undefined
        // 构造函数返回对象，以对象为准
        // 构造优先级 返回对象 > 构造内部属性方法 > 原型链上的属性方法
        // function Foo() {
        //     this.a = 1;
        //     return {
        //         a: 4,
        //         b: 5,
        //     };
        // }
        //
        // Foo.prototype.a = 6;
        // Foo.prototype.b = 7;
        // Foo.prototype.c = 8;
        //
        // var o = new Foo();
        //
        // console.log(o);
        //
        // console.log(o.a);
        // console.log(o.b);
        // console.log(o.c);

        // 看输出结果
        // let obj = {
        //     count: 3,
        //     name: 'zyc'
        // };
        //
        // console.log(obj.count); // 3
        //
        // function observe(obj) {
        //     Object.keys(obj).map((key) => {
        //         calcCount(obj, key, obj[key]);
        //     })
        // }
        //
        // function calcCount(obj, key, val) {
        //     Object.defineProperties(obj, {
        //         configurable: true,
        //         enumerable: false,
        //
        //     });
        // }
        //
        // observe(obj);
        // console.log(obj.count);


        // console.log("----------------------------------------------------------------");

        // var obj = {};
        // var aValue; //如果不初始化变量, 不给下面的a属性设置值,直接读取会报错aValue is not defined
        // var b;
        // Object.defineProperty(obj, 'a', {
        //     configurable : true,
        //     enumerable : true,
        //     get: function() {
        //         return aValue
        //     },
        //     set: function(newValue) {
        //         aValue = newValue;
        //         b = newValue + 1
        //     }
        // })
        // console.log(b) // undefined
        // console.log(obj.a)  // undefined, 当读取属性值时，调用get方法,返回undefined
        // obj.a = 2;  // 当设置属性值时,调用set方法,aValue为2
        //
        // console.log(obj.a) // 2  读取属性值,调用get方法,此时aValue为2
        // console.log(b) // 3  再

        // console.log("------------------写出输出结果---------------js连续赋值问题-------------------");
        // let a = {n: 1};
        // a.x = a = {n: 2};
        // // a.x = {n:2};
        // console.log(a); // {n:2}
        // console.log(a.x); // undefined


        // let a = {n: 1};
        // let b = a;
        // a.x = a = {n: 2};
        // console.log(a); // {n:2}
        // console.log(a.x); // undefined
        // console.log(b);   // {n: 1, x: {n:2} }
        // console.log(b.x);   // {n:2}

        // 知识点：
        // 点的优先级大于等号的优先级
        // 对象以指针的形势进行存储，每个新对象都是一份新的存储地址
        // 解析：
        // let b = a ; b 和 a 都指向同一个地址
        //  . 的优先级高于 =  。所以先执行 a.x ，于是现在的 a 和 b 都是 { n : 2 , x : undefined }
        //  = 从右向左执行。所以是执行 a = { n : 2 }，于是 a 指向了 { n : 2 } 不再是之前的地址
        //  再执行 a.x = a。这里注意，a.x 是最开始执行的（可以看作是一个整体），已经是 { n : 1 , x : undefined }
        //  而不是一开始的那个 a ，而且 b 和旧的 a 是指向同一个地址的，相当于b.x = a 。所以 b 也就变了
        //  但是，= 右边的 a 是已经指向了新地址的 a 。
        // 所以，a.x = a 可以看成是 { n : 1, x : undefined }.x = { n : 2 }

        // console.log("------------------写出输出结果---------------当时自己写错了，写错了-------------");
        //
        // async function ioDc() {
        //     console.log(1);
        //     await new Promise(resolve => resolve());
        //     console.log(2);
        // }
        //
        // new Promise(resolve => {
        //     console.log(3);
        //     resolve()
        // }).then(() => {
        //     console.log(4);
        // });
        //
        // setTimeout(() => {
        //     console.log(5)
        // });
        //
        // ioDc();
        // console.log(6);

        // console.log("--------------------一道类似题-------------------");
        // console.log("-----首先执行 宏任务同步代码 => 微任务的Event Queue => 宏任务的Event Queue-------");
        // console.log("在执行宏任务同步代码的过程中，会分别将微任务的异步和宏任务的异步放入各自的队列");
        //
        async function async1() {
            console.log('async1 start');
            await async2();
            console.log('asnyc1 end');
            await async3();
            console.log('asnyc3 end');
        }

        async function async2() {
            console.log('async2');
        }

        async function async3() {
            console.log('async3');
        }

        console.log('script start');
        setTimeout(() => {
            console.log('setTimeOut');
        }, 0);
        async1();
        new Promise(function (reslove) {
            console.log('promise1');
            reslove();
        }).then(function () {
            console.log('promise2');
        });
        console.log('script end');

        // script start
        // async1 start
        // async2
        // promise1
        // script end
        // asnyc1 end
        // promise2
        // setTimeOut


        // console.log("------------promise----可以无限往下执行--------");
        // new Promise((resolve, reject) => {
        //     console.log("promise1");
        //     resolve(1);
        // }).then((res) => {
        //     console.log(res);
        //     console.log("promise2");
        // }).then((res) => {
        //     console.log(res);
        //     console.log("promise3");
        //     "".shift();  // 报错走catch
        // })
        //     .catch((res) => {
        //     console.log(res);
        //     console.log("promise4")
        // })
        //     .finally(() => {
        //     console.log("promise5")
        // }).catch(() => {
        //     console.log("promise6") // 没报错，所以不执行
        // }).then(() => {
        //     console.log("promise7")
        // }).finally(() => {
        //     console.log("promise8")
        // }).then(() => {
        //     console.log("每次都返回promise,所以可以无限次调用~")
        // });

        // console.log("-------------async---await-----------");
        // console.log("----await表达式--下面的代码被置于微任务队列里，等待执行-----------");

        // async函数可能包含0个或者多个await表达式。
        // await表达式会暂停整个async函数的执行进程并出让其控制权，
        // 只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。
        // promise的解决值会被当作该await表达式的返回值。使用async / await关键字就可以在异步代码中使用普通的try / catch代码块。

        // async函数的函数体可以被看作是由0个或者多个await表达式分割开来的。
        // 从第一行代码直到（并包括）第一个await表达式（如果有的话）都是同步运行的。
        // 这样的话，一个不含await表达式的async函数是会同步运行的。
        // 然而，如果函数体内有一个await表达式，async函数就一定会异步执行。

        // async function foo() {
        //     return 1
        // }
        // function foo() {
        //     return Promise.resolve(1)
        // }

        // async function foo() {
        //      await 1
        //      console.log('zzz')
        // }
        // function foo() {
        //     Promise.resolve(1).then(() => {
        //         console.log('zzz')
        //     })
        // }

        // function getName() {
        //     console.log("zyc");
        // }
        //
        // async function asyDcTest() {
        //     console.log("111111");
        //     await getName();
        //     console.log("222222");
        // }
        //
        // setTimeout(() => {
        //     console.log("setTimeout");
        // }, 0);
        // console.log("script start");
        // asyDcTest();
        // console.log("promise start");
        // new Promise((resolve, reject) => {
        //     console.log("new Promise");
        //     resolve("qwe")
        // }).then(() => {
        //     console.log("new Promise then");
        // })

        // script start
        // 111111
        // zyc
        // promise start
        // new Promise
        // 222222
        // new Promise then
        // setTimeout


    };
</script>
</html>


