<!-- 看看输出什么值-->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
        }

    </style>
</head>
<body>
<div style="text-align: center">
    <!--    <button onclick="onClickButton()">点击</button>-->
</div>
</body>
<script>

    // function onClickButton() {
    // abhdcba
    // console.log('abcdcba'.replace(/c/, "h"));
    // console.log("点击");
    // for (let i = 0; i < 3; i++) {
    //     console.log(i);
    // }
    // }

    window.onload = function () {
        // // 0 1 2
        // for (let i = 0; i < 3; i++) {
        //     document.body.addEventListener('click', function () {
        //         console.log(i);
        //     });
        // }
        //
        // // 3 3 3
        // for (var i = 0; i < 3; i++) {
        //     document.body.addEventListener('click', function () {
        //         console.log(i);
        //     });
        // }


        // 1,2,3,4,5
        // const tempArr = [1,2,3,4,5];
        // for (let i = 0; i < tempArr.length; i++) {
        //     setTimeout( () => {
        //         console.log(tempArr[i]);
        //     },0)
        // }
        //
        // // 5 undefined 5 undefined 5 undefined 5 undefined 5 undefined
        // const tempArr2 = [1,2,3,4,5];
        // for (var i = 0; i < tempArr2.length; i++) {
        //     setTimeout( () => {
        //         console.log(i);
        //         console.log(tempArr2[i]);
        //     },0)
        // }


        // undefined
        // js链式作用域 JS权威指南的描述：
        // JavaScript中的函数运行在他们被定义的作用域里，而不是他们被执行的作用域里。
        // 这句话很难理解，但是换做简单的描述，JS的链式作用域就是：
        // JS中当遇到对变量名或者函数名的使用时，会首先在当前作用域查找变量或者函数,如果没有找到，就会到其上层作用域中寻找，并以此类推。
        // var a = 1;
        // function fn() {
        //     console.log(a);
        //     var a = 2;
        // }
        // fn();

        // Uncaught ReferenceError: Cannot access 'b' before initialization
        // let b = 1;
        // function fnb() {
        //     // console.log(b);
        //     // let b = 2;
        //     var bc = 3;
        //     var bc = 4;
        // }
        // fnb();

        // 20
        // var count = 10;
        // function a() {
        //     return count + 10;
        // }
        //
        // function b() {
        //     var count = 20;
        //     console.log(this);
        //     console.log(this.count);
        //     return a();
        // }
        //
        // let objj = {
        //     count: 50,
        //     dcdc: function dcdc() {
        //     return  this.count;
        // },
        // };
        //
        // var dcdcdc = objj.dcdc;
        // console.log(dcdcdc());
        // console.log(objj.dcdc());
        // console.log(b());
        //
        // // 错 2
        // Function.prototype.a = () => alert(1);
        // Object.prototype.b = () => alert(2);
        // function A() {};
        // var a = new A();
        // a.a();
        // console.log(a);
        // a.b();


        // 4 5 undefined
        // 构造函数返回对象，以对象为准
        // 构造优先级 返回对象 > 构造内部属性方法 > 原型链上的属性方法
        // function Foo() {
        //     this.a = 1;
        //     return {
        //         a: 4,
        //         b: 5,
        //     };
        // }
        //
        // Foo.prototype.a = 6;
        // Foo.prototype.b = 7;
        // Foo.prototype.c = 8;
        //
        // var o = new Foo();
        //
        // console.log(o);
        //
        // console.log(o.a);
        // console.log(o.b);
        // console.log(o.c);

        // 看输出结果
        // let obj = {
        //     count: 3,
        //     name: 'zyc'
        // };
        //
        // console.log(obj.count); // 3
        //
        // function observe(obj) {
        //     Object.keys(obj).map((key) => {
        //         calcCount(obj, key, obj[key]);
        //     })
        // }
        //
        // function calcCount(obj, key, val) {
        //     Object.defineProperties(obj, {
        //         configurable: true,
        //         enumerable: false,
        //
        //     });
        // }
        //
        // observe(obj);
        // console.log(obj.count);


        console.log("----------------------------------------------------------------");

        // var obj = {};
        // var aValue; //如果不初始化变量, 不给下面的a属性设置值,直接读取会报错aValue is not defined
        // var b;
        // Object.defineProperty(obj, 'a', {
        //     configurable : true,
        //     enumerable : true,
        //     get: function() {
        //         return aValue
        //     },
        //     set: function(newValue) {
        //         aValue = newValue;
        //         b = newValue + 1
        //     }
        // })
        // console.log(b) // undefined
        // console.log(obj.a)  // undefined, 当读取属性值时，调用get方法,返回undefined
        // obj.a = 2;  // 当设置属性值时,调用set方法,aValue为2
        //
        // console.log(obj.a) // 2  读取属性值,调用get方法,此时aValue为2
        // console.log(b) // 3  再

        console.log("------------------写出输出结果---------------js连续赋值问题-------------------");
        // let a = {n: 1};
        // a.x = a = {n: 2};
        // // a.x = {n:2};
        // console.log(a); // {n:2}
        // console.log(a.x); // undefined
        let a = {n: 1};
        let b = a;
        a.x = a = {n: 2};
        console.log(a.x); // undefined
        console.log(b);   // {n: 1, x: {n:2} }
        console.log(b.x);   // {n:2}



        console.log("------------------写出输出结果---------------当时自己写错了，写错了-------------");

        async function ioDc() {
            console.log(1);
            await new Promise(resolve => resolve());
            console.log(2);
        }

        new Promise(resolve => {
            console.log(3);
            resolve()
        }).then(() => {
            console.log(4);
        });

        setTimeout(() => {
            console.log(5)
        });

        ioDc();
        console.log(6);


    };
</script>
</html>


