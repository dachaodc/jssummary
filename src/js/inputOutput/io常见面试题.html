<!-- 看看输出什么值-->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
        }

    </style>
</head>
<body>
<div style="text-align: center">
    <!--    <button onclick="onClickButton()">点击</button>-->
</div>
</body>
<script>

    // function onClickButton() {
    // abhdcba
    // console.log('abcdcba'.replace(/c/, "h"));
    // console.log("点击");
    // for (let i = 0; i < 3; i++) {
    //     console.log(i);
    // }
    // }

    window.onload = function () {
        // 0 1 2
        for (let i = 0; i < 3; i++) {
            document.body.addEventListener('click', function () {
                console.log(i);
            });
        }

        // 3 3 3
        for (var i = 0; i < 3; i++) {
            document.body.addEventListener('click', function () {
                console.log(i);
            });
        }

        // undefined
        // js链式作用域 JS权威指南的描述：
        // JavaScript中的函数运行在他们被定义的作用域里，而不是他们被执行的作用域里。
        // 这句话很难理解，但是换做简单的描述，JS的链式作用域就是：
        // JS中当遇到对变量名或者函数名的使用时，会首先在当前作用域查找变量或者函数,如果没有找到，就会到其上层作用域中寻找，并以此类推。
        // var a = 1;
        // function fn() {
        //     console.log(a);
        //     var a = 2;
        // }
        // fn();

        // Uncaught ReferenceError: Cannot access 'b' before initialization
        // let b = 1;
        // function fnb() {
        //     // console.log(b);
        //     // let b = 2;
        //     var bc = 3;
        //     var bc = 4;
        // }
        // fnb();

        // 20
        // var count = 10;
        // function a() {
        //     return count + 10;
        // }
        //
        // function b() {
        //     var count = 20;
        //     console.log(this);
        //     console.log(this.count);
        //     return a();
        // }
        //
        // let objj = {
        //     count: 50,
        //     dcdc: function dcdc() {
        //     return  this.count;
        // },
        // };
        //
        // var dcdcdc = objj.dcdc;
        // console.log(dcdcdc());
        // console.log(objj.dcdc());
        // console.log(b());
        //
        // // 错 2
        // Function.prototype.a = () => alert(1);
        // Object.prototype.b = () => alert(2);
        // function A() {};
        // var a = new A();
        // a.a();
        // console.log(a);
        // a.b();


        // 4 5 undefined
        // 构造函数返回对象，以对象为准
        // 构造优先级 返回对象 > 构造内部属性方法 > 原型链上的属性方法
        function Foo() {
            this.a = 1;
            return {
                a: 4,
                b: 5,
            };
        }

        Foo.prototype.a = 6;
        Foo.prototype.b = 7;
        Foo.prototype.c = 8;

        var o = new Foo();

        console.log(o);

        console.log(o.a);
        console.log(o.b);
        console.log(o.c);





    };
</script>
</html>


